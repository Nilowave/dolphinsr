{"version":3,"file":"bundle.mjs","sources":["../lib/types.js","../lib/addReview.js","../lib/dateDiffInDays.js","../lib/computeCardsSchedule.js","../lib/applyReview.js","../lib/index.js"],"sourcesContent":["// @flow\n\nimport uuid from 'uuid';\n\n// Generally all types should be considered opaque in application code.\n\n// -- Data types\n\nexport type Id = string;\nexport function generateId(): Id {\n  return uuid.v4();\n}\n\nexport type Field = string;\n\n// numbers are indexes on master.fields\nexport type Combination = {front: number[], back: number[], };\n\nexport type CardId = string;\nexport function getCardId(o: {master: Id, combination: Combination}): CardId {\n  return `${o.master}#${o.combination.front.join(',')}@${o.combination.back.join(',')}`;\n}\n\n\nexport type Master = {\n  id: Id,\n  fields: Array<Field>,\n  combinations: Array<Combination>,\n}\n\nexport type Rating = 'easy' | 'good' | 'hard' | 'again';\n\nexport type Review = {\n  master: Id,\n  combination: Combination,\n  ts: Date,\n  rating: Rating,\n}\n\n// -- Computed data types\n\nexport type Card = {\n  master: Id,\n  combination: Combination,\n  front: Field[],\n  back: Field[]\n};\n\nexport type LearningCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'learning',\n  consecutiveCorrect: number, // 0 <= consecutiveCorrect < 2, int\n  lastReviewed: ?Date\n};\nexport type ReviewingCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'reviewing',\n  factor: number, // float\n  lapses: number, // int\n  interval: number, // days since lastReviewed\n  lastReviewed: Date\n};\nexport type LapsedCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'lapsed',\n  consecutiveCorrect: number,\n  factor: number,\n  lapses: number,\n  interval: number,\n  lastReviewed: Date,\n};\nexport type CardState = LearningCardState | ReviewingCardState | LapsedCardState;\nexport function makeInitialCardState(master: Id, combination: Combination): LearningCardState {\n  return {\n    master,\n    combination,\n\n    mode: 'learning',\n    consecutiveCorrect: 0,\n    lastReviewed: null,\n  };\n}\n\nexport type State = {\n  cardStates: {[CardId]: CardState},\n};\nexport function makeEmptyState(): State {\n  return {\n    cardStates: {},\n  };\n}\n\nexport type Schedule = 'later' | 'due' | 'overdue' | 'learning';\nexport function cmpSchedule(a: Schedule, b: Schedule) {\n  const scheduleVals = {\n    later: 0,\n    due: 1,\n    overdue: 2,\n    learning: 3,\n  };\n  const diff = scheduleVals[b] - scheduleVals[a];\n  if (diff < 0) {\n    return -1;\n  } else if (diff > 0) {\n    return 1;\n  }\n  return 0;\n}\n\nexport type CardsSchedule = {\n  'later': Array<CardId>,\n  'due': Array<CardId>,\n  'overdue': Array<CardId>,\n  'learning': Array<CardId>\n};\n\nexport type SummaryStatistics = {\n  'later': number,\n  'due': number,\n  'overdue': number,\n  'learning': number\n};\n","// @flow\nimport type { Review } from './types';\n\n// This function only works if reviews is always sorted by timestamp\nexport default function addReview(reviews: Review[], review: Review): Review[] {\n  if (!reviews.length) {\n    return [review];\n  }\n\n  let i = reviews.length - 1;\n  for (; i >= 0; i -= 1) {\n    if (reviews[i].ts <= review.ts) {\n      break;\n    }\n  }\n\n  const newReviews = reviews.slice(0);\n  newReviews.splice(i + 1, 0, review);\n\n  return newReviews;\n}\n","// @flow\n\nexport default function dateDiffInDays(a: Date, b: Date): number {\n  // adapted from http://stackoverflow.com/a/15289883/251162\n  const MS_PER_DAY = 1000 * 60 * 60 * 24;\n\n  // Disstate the time and time-zone information.\n  const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());\n  const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());\n\n  return (utc2 - utc1) / MS_PER_DAY;\n}\n","// @flow\n\nimport type {\n  CardState,\n  ReviewingCardState,\n  Schedule,\n  CardsSchedule,\n  State,\n  CardId,\n} from \"./types\";\nimport { getCardId } from \"./types\";\nimport dateDiffInDays from \"./dateDiffInDays\";\n\n// assumes that the day starts at 3:00am in the local timezone\nexport function calculateDueDate(state: ReviewingCardState): Date {\n  const result = new Date(state.lastReviewed);\n  result.setHours(3, 0, 0);\n  result.setDate(result.getDate() + Math.ceil(state.interval));\n  return result;\n}\n\nexport function computeScheduleFromCardState(\n  state: CardState,\n  now: Date\n): Schedule {\n  if (state.mode === \"lapsed\" || state.mode === \"learning\") {\n    return \"learning\";\n  } else if (state.mode === \"reviewing\") {\n    const diff = dateDiffInDays(calculateDueDate(state), now);\n    if (diff < 0) {\n      return \"later\";\n    } else if (diff >= 0 && diff < 1) {\n      return \"due\";\n    } else if (diff >= 1) {\n      return \"overdue\";\n    }\n  }\n  throw new Error(\"unreachable\");\n}\n\n// Breaks ties first by last review (earlier beats later),\n// then by an alphabetical comparison of the cardId (just so it stays 100% deterministic)\n//\n// Returns null if no cards are due.\nexport function pickMostDue(s: CardsSchedule, state: State): ?CardId {\n  const prec: Schedule[] = [\"learning\", \"overdue\", \"due\"];\n  for (let i = 0; i < prec.length; i += 1) {\n    const sched = prec[i];\n    if (s[sched].length) {\n      return s[sched].slice(0).sort((a, b) => {\n        const cardA = state.cardStates[a];\n        const cardB = state.cardStates[b];\n        if (cardA == null) {\n          throw new Error(`id not found in state: ${a}`);\n        }\n        if (cardB == null) {\n          throw new Error(`id not found in state: ${b}`);\n        }\n\n        const reviewDiff =\n          cardA.lastReviewed == null && cardB.lastReviewed != null\n            ? 1\n            : cardB.lastReviewed == null && cardA.lastReviewed != null\n            ? -1\n            : cardA.lastReviewed == null && cardB.lastReviewed == null\n            ? 0\n            : (cardB.lastReviewed: any) - (cardA.lastReviewed: any);\n        if (reviewDiff !== 0) {\n          return -reviewDiff;\n        }\n        if (reviewDiff === 0) {\n          return reviewDiff;\n        }\n\n        if (a === b) {\n          throw new Error(`comparing duplicate id: ${a}`);\n        }\n        return b > a ? 1 : -1;\n      })[0];\n    }\n  }\n  return null;\n}\n\nexport default function computeCardsSchedule(\n  state: State,\n  now: Date\n): CardsSchedule {\n  const s: CardsSchedule = {\n    learning: [],\n    later: [],\n    due: [],\n    overdue: [],\n  };\n  Object.keys(state.cardStates).forEach((cardId) => {\n    const cardState = state.cardStates[cardId];\n    s[computeScheduleFromCardState(cardState, now)].push(getCardId(cardState));\n  });\n  return s;\n}\n","// @flow\n\nimport type {\n  State,\n  CardState,\n  LearningCardState,\n  ReviewingCardState,\n  LapsedCardState,\n  Review,\n  Rating,\n} from \"./types\";\nimport { getCardId } from \"./types\";\nimport dateDiffInDays from \"./dateDiffInDays\";\nimport { calculateDueDate } from \"./computeCardsSchedule\";\n\nconst debug = require(\"debug\")(\"dolphin\");\n\n// -- applyToLearningCardState(...)\n\n// constants from Anki defaults\n// TODO(April 1, 2017) investigate rationales, consider changing them\nconst INITIAL_FACTOR = 130;\nconst INITIAL_DAYS_WITHOUT_JUMP = 4;\nconst INITIAL_DAYS_WITH_JUMP = 1;\nfunction applyToLearningCardState(\n  prev: LearningCardState,\n  ts: Date,\n  rating: Rating\n): CardState {\n  if (\n    rating === \"easy\" ||\n    (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)\n  ) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: \"reviewing\",\n      factor: INITIAL_FACTOR,\n      lapses: 0,\n      interval:\n        prev.consecutiveCorrect > 0\n          ? INITIAL_DAYS_WITHOUT_JUMP\n          : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  } else if (rating === \"again\") {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: \"learning\",\n      consecutiveCorrect: 0,\n      lastReviewed: ts,\n    };\n  } else if (rating.match(/^good|hard$/) && prev.consecutiveCorrect < 1) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: \"learning\",\n      consecutiveCorrect: prev.consecutiveCorrect + 1,\n      lastReviewed: ts,\n    };\n  }\n  throw new Error(\"logic error\");\n}\n\n// -- applyToReviewingCardState(...)\n\nconst EASY_BONUS = 2;\nconst MAX_INTERVAL = 365;\nconst MIN_FACTOR = 130; // TODO\nconst MAX_FACTOR = Number.MAX_VALUE;\nfunction constrainWithin(min, max, n) {\n  if (min > max) {\n    throw new Error(`min > max: ${min}=min, ${max}=max`);\n  }\n  return Math.max(Math.min(n, max), min);\n}\n\nfunction calculateDaysLate(state: ReviewingCardState, actual: Date): number {\n  const expected = calculateDueDate(state);\n\n  const daysLate = dateDiffInDays(actual, expected);\n\n  if (daysLate < 0) {\n    debug(\"last review occured earlier than expected\", {\n      daysLate,\n      actual,\n      expected,\n    });\n    return 0;\n  }\n\n  return daysLate;\n}\nfunction applyToReviewingCardState(\n  prev: ReviewingCardState,\n  ts: Date,\n  rating: Rating\n): CardState {\n  if (rating === \"again\") {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: \"lapsed\",\n      consecutiveCorrect: 0,\n      factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor - 0), //200\n      lapses: prev.lapses + 1,\n      interval: prev.interval,\n      lastReviewed: ts,\n    };\n  }\n  const factorAdj =\n    rating === \"hard\"\n      ? 0 // -150\n      : rating === \"good\"\n      ? 0\n      : rating === \"easy\"\n      ? 0 // 0\n      : NaN;\n  const daysLate = calculateDaysLate(prev, ts);\n\n  const ival = constrainWithin(\n    prev.interval + 1,\n    MAX_INTERVAL,\n    rating === \"hard\"\n      ? (prev.interval + daysLate / 4) * 1.2\n      : rating === \"good\"\n      ? ((prev.interval + daysLate / 2) * prev.factor) / 1000\n      : rating === \"easy\"\n      ? (((prev.interval + daysLate) * prev.factor) / 1000) * EASY_BONUS\n      : NaN\n  );\n\n  if (isNaN(factorAdj) || isNaN(ival)) {\n    throw new Error(`invalid rating: ${rating}`);\n  }\n\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: \"reviewing\",\n    factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor + factorAdj),\n    lapses: prev.lapses,\n    interval: ival,\n    lastReviewed: ts,\n  };\n}\n\n// -- applyToLapsedCardState(...)\n\nfunction applyToLapsedCardState(\n  prev: LapsedCardState,\n  ts: Date,\n  rating: Rating\n): CardState {\n  if (\n    rating === \"easy\" ||\n    (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)\n  ) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: \"reviewing\",\n      factor: prev.factor,\n      lapses: prev.lapses,\n      interval:\n        prev.consecutiveCorrect > 0\n          ? INITIAL_DAYS_WITHOUT_JUMP\n          : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  }\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: \"lapsed\",\n    factor: prev.factor,\n    lapses: prev.lapses,\n    interval: prev.interval,\n    lastReviewed: ts,\n    consecutiveCorrect: rating === \"again\" ? 0 : prev.consecutiveCorrect + 1,\n  };\n}\n\n// -- applyReview(...)\n\nexport function applyToCardState(\n  prev: CardState,\n  ts: Date,\n  rating: Rating\n): CardState {\n  if (prev.lastReviewed != null && prev.lastReviewed > ts) {\n    const p = prev.lastReviewed.toISOString();\n    const t = ts.toISOString();\n    throw new Error(\n      `cannot apply review before current lastReviewed: ${p} > ${t}`\n    );\n  }\n\n  if (prev.mode === \"learning\") {\n    return applyToLearningCardState((prev: any), ts, rating);\n  } else if (prev.mode === \"reviewing\") {\n    return applyToReviewingCardState((prev: any), ts, rating);\n  } else if (prev.mode === \"lapsed\") {\n    return applyToLapsedCardState((prev: any), ts, rating);\n  }\n  throw new Error(`invalid mode: ${prev.mode}`);\n}\n\nexport default function applyReview(prev: State, review: Review): State {\n  const cardId = getCardId(review);\n\n  const cardState = prev.cardStates[cardId];\n  if (cardState == null) {\n    throw new Error(\n      `applying review to missing card: ${JSON.stringify(review)}`\n    );\n  }\n\n  const state = {\n    cardStates: { ...prev.cardStates },\n  };\n  state.cardStates[cardId] = applyToCardState(\n    cardState,\n    review.ts,\n    review.rating\n  );\n\n  return state;\n}\n","// @flow\n\nimport type {\n  State,\n  Master,\n  Review,\n  Id,\n  CardId,\n  CardsSchedule,\n  Card,\n  SummaryStatistics,\n} from \"./types\";\nimport {\n  makeEmptyState,\n  getCardId,\n  makeInitialCardState,\n  generateId,\n} from \"./types\";\nimport addReview from \"./addReview\";\nimport applyReview from \"./applyReview\";\nimport computeCardsSchedule, { pickMostDue } from \"./computeCardsSchedule\";\n\nexport type { Master, Review, Id, Card, SummaryStatistics };\nexport { generateId };\n\nconst debug = require(\"debug\")(\"dolphin\");\n\nexport class DolphinSR {\n  _state: State;\n  _masters: { [Id]: Master };\n  _reviews: Array<Review>;\n\n  // TODO(April 3, 2017)\n  // Currently the cachedCardsSchedule is not invalidated when the time changes (only when a review\n  // or master is added), so there is a possibility for cards not switching from due to overdue\n  // properly. In practice, this has not been a significant issue -- easy fix for later.\n  _cachedCardsSchedule: ?CardsSchedule;\n\n  // For testing, you can swap this out with a different function to change when 'now' is.\n  _currentDateGetter: () => Date;\n\n  constructor(currentDateGetter: () => Date = () => new Date()) {\n    this._state = makeEmptyState();\n    this._masters = {};\n    this._reviews = [];\n    this._currentDateGetter = currentDateGetter;\n  }\n\n  // gotcha: does not invalidate cache, that happens in addMasters()\n  _addMaster(master: Master) {\n    if (this._masters[master.id]) {\n      throw new Error(`master already added: ${master.id}`);\n    }\n    master.combinations.forEach((combination) => {\n      const id = getCardId({ master: master.id, combination });\n      this._state.cardStates[id] = makeInitialCardState(master.id, combination);\n    });\n    this._masters[master.id] = master;\n  }\n\n  addMasters(...masters: Array<Master>) {\n    masters.forEach((master) => this._addMaster(master));\n    this._cachedCardsSchedule = null;\n  }\n\n  // gotcha: does not apply the reviews to state or invalidate cache, that happens in addReviews()\n  _addReviewToReviews(review: Review): boolean {\n    this._reviews = addReview(this._reviews, review);\n    const lastReview = this._reviews[this._reviews.length - 1];\n\n    return (\n      `${getCardId(lastReview)}#${lastReview.ts.toISOString()}` !==\n      `${getCardId(review)}#${review.ts.toISOString()}`\n    );\n  }\n\n  // Returns true if the entire state was rebuilt (inefficient, minimize)\n  addReviews(...reviews: Array<Review>): boolean {\n    const needsRebuild = reviews.reduce((v, review) => {\n      if (this._addReviewToReviews(review)) {\n        return true;\n      }\n      return v;\n    }, false);\n\n    if (needsRebuild) {\n      this._rebuild();\n    } else {\n      reviews.forEach((review) => {\n        this._state = applyReview(this._state, review);\n      });\n    }\n\n    this._cachedCardsSchedule = null;\n\n    return needsRebuild;\n  }\n\n  _rebuild() {\n    debug(\"rebuilding state\");\n    const masters = this._masters;\n    const reviews = this._reviews;\n    this._masters = {};\n    this._reviews = [];\n\n    this.addMasters(...Object.keys(masters).map((k) => masters[k]));\n    this.addReviews(...reviews);\n  }\n\n  _getCardsSchedule(): CardsSchedule {\n    if (this._cachedCardsSchedule != null) {\n      return this._cachedCardsSchedule;\n    }\n    this._cachedCardsSchedule = computeCardsSchedule(\n      this._state,\n      this._currentDateGetter()\n    );\n    return this._cachedCardsSchedule;\n  }\n\n  _nextCardId(): ?CardId {\n    const s = this._getCardsSchedule();\n    return pickMostDue(s, this._state);\n  }\n\n  _getCard(id: CardId): Card {\n    const [masterId, combo] = id.split(\"#\");\n    const [front, back] = combo\n      .split(\"@\")\n      .map((part) => part.split(\",\").map((x) => parseInt(x, 10)));\n    const master = this._masters[masterId];\n    if (master == null) {\n      throw new Error(`cannot getCard: no such master: ${masterId}`);\n    }\n    const combination = { front, back };\n\n    const frontFields = front.map((i) => master.fields[i]);\n    const backFields = back.map((i) => master.fields[i]);\n\n    const cardMeta = this._state.cardStates[id];\n\n    return {\n      ...cardMeta,\n      master: masterId,\n      combination,\n\n      front: frontFields,\n      back: backFields,\n    };\n  }\n\n  nextCard(): ?Card {\n    const cardId = this._nextCardId();\n    if (cardId == null) {\n      return null;\n    }\n    return this._getCard(cardId);\n  }\n\n  summary(): SummaryStatistics {\n    const s = this._getCardsSchedule();\n    return {\n      due: s.due.length,\n      later: s.later.length,\n      learning: s.learning.length,\n      overdue: s.overdue.length,\n    };\n  }\n}\n"],"names":["generateId","uuid","v4","getCardId","o","master","combination","front","join","back","makeInitialCardState","makeEmptyState","addReview","reviews","review","length","i","ts","newReviews","slice","splice","dateDiffInDays","a","b","MS_PER_DAY","utc1","Date","UTC","getFullYear","getMonth","getDate","utc2","calculateDueDate","state","result","lastReviewed","setHours","setDate","Math","ceil","interval","computeScheduleFromCardState","now","mode","diff","Error","pickMostDue","s","prec","sched","sort","cardA","cardStates","cardB","reviewDiff","computeCardsSchedule","keys","forEach","cardId","cardState","push","debug","require","INITIAL_FACTOR","INITIAL_DAYS_WITHOUT_JUMP","INITIAL_DAYS_WITH_JUMP","applyToLearningCardState","prev","rating","match","consecutiveCorrect","EASY_BONUS","MAX_INTERVAL","MIN_FACTOR","MAX_FACTOR","Number","MAX_VALUE","constrainWithin","min","max","n","calculateDaysLate","actual","expected","daysLate","applyToReviewingCardState","factor","lapses","factorAdj","NaN","ival","isNaN","applyToLapsedCardState","applyToCardState","p","toISOString","t","applyReview","JSON","stringify","DolphinSR","currentDateGetter","_state","_masters","_reviews","_currentDateGetter","id","combinations","masters","_addMaster","_cachedCardsSchedule","lastReview","needsRebuild","reduce","v","_addReviewToReviews","_rebuild","addMasters","Object","map","k","addReviews","_getCardsSchedule","split","masterId","combo","part","x","parseInt","frontFields","fields","backFields","cardMeta","_nextCardId","_getCard","due","later","learning","overdue"],"mappings":"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"}